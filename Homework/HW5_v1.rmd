---
title: "Computing HW #5 Group 5"
output: html_notebook
---
99.
```{r}
count_chars_in_table=function(x, y){
  x=strsplit(x, split="")
  x=lapply(x, match, y, nomatch=NA)
  x=lapply(x, na.exclude)
  x=sapply(x, length)
  return(x)
}
count_chars_in_table("Wien", letters[1:13])
```

100.
```{r}
upcase=function(x){
  x=gsub("[^A-Z]", "", x)
  x=x[x!=""]
  return(unlist(lapply(x, nchar)))
}
upcase(c("Bb", "AAA", "Wien", "LEBERKASE"))
```

101.
```{r}
strrev=function(string){
  return(paste(rev(unlist(strsplit(string, split=""))), collapse=""))
}
strrev("ABC")
```
102.
```{r}
nwords=function(char_vec){
  input_list=strsplit(char_vec, " ")
  return(unlist(lapply(input_list, length)))
}
nwords(c("v", "a l", "e, n t i n a"))
```
103.
```{r}
"a) 
answer should be the sum of 1 to 5 which is 15 "
answer=0; for(j in 1:5) answer=answer+j
answer

"b)
answer should be the vector containing 1 to 5"
answer=NULL; for(j in 1:5) answer=c(answer, j)
answer

"c)
answer should be the vector containing 0 to 5"
answer=0; for(j in 1:5) answer=c(answer, j)
answer

"d)
answer should be the product of 1 to 5 which is 120"
answer=1; for(j in 1:5) answer=answer*j
answer

"e)
vector starting with 3, 7*3%%31=21, 7*21%%31 and so on"
answer=3
for(j in 1:15) answer=c(answer, (7*answer[j])%%31)
answer
"Any finite sequence can be generated by multiple formulas which can diverge for later elements."
```

104.

```{r}
cfrac<-function(x) {
  n<-length(x)
  b<-x[n]
  for (i in 1:n-1){
    z <- 1/b
    b <- x[n-i]+z
  }
  return(b)
}

y<-c(3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1)
cfrac(y)
cfrac(y)-pi
cfrac(y)==pi
```
105.
```{r}
contfrac<-function(x) {
  y<-rev(x)
  k<-length(x)
  den<-y[1]*y[2]+1
  nom<-y[1]
  for (i in 3:k) {
    aux<-den
    den<-den*y[i]+nom
    nom<-aux
  }
  print(den)
  print(nom)
}

x<-c(4,2,6,7)
contfrac(x)
z<-c(3, 7, 15, 1, 292)
contfrac(z)
103933/33102 # Result is 3.13978
y<-c(3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1)
contfrac(y)
411557987/131002976 # Result is 3.141593
```

112. 
```{r}
factorize <- function(n) {
  if (n<2) {return("not a composite number")}
  res <- numeric(1)
  pos <- 1
  
  while( n%%2 == 0) {
    res[pos] <- 2
    pos <- pos+1
    n <- n/2
  }
  f <- 3
  while(f*f <= n) {
    if(n %% f == 0) {
      res[pos] <- f
      pos <- pos+1
      n <- n/f
    }
    else {f <- f+2}
  }
  if(n != 1) {res[pos] <- n}
  return(res)
}
factorize(120)
```
113.
```{r}
gcd <- function(a,b) {
  if(b == 0) { return(a) }
  if(a %% b == 0) { return(b) }
  else {
    return(gcd(b, a %% b))
  }
}

is_prime <- function(n) {
  if(n == 1) { return(FALSE) }
  if(n == 2) { return(TRUE) }
  for(i in 2:floor(sqrt(n))) {
    if( gcd(n,i) != 1 ) { return(FALSE) }
  }
  return(TRUE)
}

res <- list(numeric(1))
pos <- 1
for(i in 2:998) {
  if(is_prime(i) & is_prime(i+2)) {
    res[[pos]] <- i
    res[[pos]][2] <- i+2
    pos <- pos+1
  }
}
print(res)
```



114.
```{r}
fibonacci <- function(n) {
  first <- 0
  second <- 1
  for(i in 0:(n-1)) {
    second <- first + second
    first <- second - first
  }
  return(first)
}
fibonacci(15)
fibonacci(43)

# (a) - Converging to Golden ratio
res <- numeric(1)
for(i in 1:30) {
  res[i] <- fibonacci(i+1)/fibonacci(i)	
}
print(res)

# (b) - Yes Fibonacci sequence converging to golden ratio
golden_ratio <- (1+sqrt(5))/2
```

115.
just to check numbers are correct:
http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibtable.html
```{r}
number_of_fibonacci <- function(n) {
  res <- numeric(1)
  i <- 1
  
  while(fibonacci(i) < n) {
    res[i] <- fibonacci(i)
    i <- i+1
  }
  return(length(res))
}
number_of_fibonacci(1000000)
```





#116
```{r}

fibonacci_log <- function(n) {
  tmp <- c(1,0)
  n_temp <- n
  
  if( n %% 2 != 0) {
    tmp <- c(tmp[1]+tmp[2],tmp[1])
    n_temp <- n_temp - 1
  }
  for(i in 1:(n_temp/2)) {
    tmp <- c(2*tmp[1]+tmp[2],tmp[1]+tmp[2])
  }
  
  return(tmp[2])
}



```



#117

```{r}

pairs <- function(n) {
  res <- list(numeric(n*n))
  
  q<-1
  for(i in 1:(n-1)) {
    for (j in (i+1):n) {
      res[[q]] <- c(i,j)
      q <- q+1
    }
  }
  return(res)
}



```


#118

```{r}

k_tuples <- function(n,k) {
  x <- list(1:n)
  tmp <- expand.grid(rep(x, k)) #all possible combinations
  check <- NULL
  for (i in 1:nrow(tmp)){
    for (j in 2:ncol(tmp))
      if(tmp[i,j]>tmp[i,j-1]){
        check[i]<-T
      }else{
        check[i]<-F
        break
      }
  }
  return(tmp[check,])
}



```


#119
```{r}

josephus <- function(n) {
  return( 2*(n-2^floor(log(n, base=2)))+1 )
}
josephus(24)


```


#120

```{r}
directpoly <- function(x,a) {
  res <- rep(list(rep(0,1)),length(x))
  res_1 <- numeric(1)
  for(j in 1:length(x)) {
    for(i in 1:length(a)) {
      res[[j]][i] <- a[i]*(x[j])^(i-1)
    }
  }
  for(i in 1:length(res)) {
    res_1[i] <- sum(res[[i]])
  }	
  
  return(res_1)
}





```


#121
```{r}

hornerpoly <- function(x,a) {
  res <- numeric(length(x))
  for(j in 1:length(x)) {
    v <- a
    for(i in (length(a)-1):1) {
      v[i] <- (v[i+1]*x[j]) + a[i]
    }
    res[j]<-v[1]
  }
  return(res)
}


```


#122

```{r}

#a
a <- system.time(directpoly(seq(-10,10, length.out=5000000),c(1, -2, 2, 3, 4, 6, 7)))
b <- system.time(hornerpoly(seq(-10,10, length.out=5000000),c(1, -2, 2, 3, 4, 6, 7)))
# hornerpoly is much faster
time <- (a - b)

#b
a <- system.time(directpoly(seq(-10,10, length.out=5000000),c(-3,17,2)))
b <- system.time(hornerpoly(seq(-10,10, length.out=5000000),c(-3,17,2)))
# hornerpoly is faster
time <- (a - b)

```

#123

```{r}




```


#124

```{r}
count <- function(pat, str, c=0) {
  if(regexpr(pat, str)[1] < 1) { return(c) }
  return(count(pat,substring(str,regexpr(pat, str)[1] + nchar(pat)),c+1))
}
count("ab", "abab cd cdab ab ab ab ")


```


#125

```{r}

k_tuples <- function(n,k) {
  if(n < k) { return (" n < k not permitted") }
  if(n == k) { return ("111") }
  
  x <- list(0:1)
  tmp <- expand.grid(rep(x, n))
  u <- nrow(tmp)
  mylist <- list()
  res <- list()
  p <- 1
  
  for(i in 1:nrow(tmp)) {
    mylist[[i]] = as.numeric(as.vector(tmp[i,]))
    if(sum(mylist[[i]]) == k) { 
      res[[p]] <- mylist[[i]] 
      p <- p+1
    }
  }
  return(res)
}
k_tuples(3,2)
k_tuples(2,1)


```

#126


```{r}

to_octal <- function(n) {
  res <- numeric(floor(log(n, base=8))+1)
  temp <- n
  for(i in 1:length(res)) {
    tmp <- floor( temp / (8^(floor(log(n, base=8))+1-i)) )
    res[i] <- tmp
    temp <- temp - tmp*(8^(floor(log(n, base=8))-i+1))
  }
  return(res)
}
to_octal(51)
to_octal(20)


```





